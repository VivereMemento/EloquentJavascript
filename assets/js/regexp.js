// У нескольких групп символов есть свои встроенные сокращения.

// \d Любая цифра
// \w Алфавитно-цифровой символ
// \s Пробельный символ (пробел, табуляция, перевод строки, и т.п.)
// \D не цифра
// \W не алфавитно-цифровой символ
// \S не пробельный символ
// . любой символ, кроме перевода строки

// найти любой символ, кроме тех, что есть в наборе – 
// можно, поставив знак ^ сразу после открывающей квадратной скобки.

// МЕТОДЫ ДЛЯ РЕГУЛЯРОК - test and exec

// Метод test – самый простой метод проверки регулярок.
// Он только сообщает, было ли найдено совпадение, или нет.
// метод exec, который вернёт null, если ничего не было найдено,
// а в противном случае вернёт объект с информацией о совпадении.

var notBinary = /[^01]/;
console.log(notBinary.test("1100100010100110"));
// → false
console.log(notBinary.test("1100100010200110"));
// → true

// знак + - элемент может быть повторён более одного раза
console.log(/'\d+'/.test("'123'"));
// → true
console.log(/'\d+'/.test("''"));
// → false

// У * - значение почти такое же, но она разрешает шаблону присутствовать ноль раз.
console.log(/'\d*'/.test("'123'"));
// → true
console.log(/'\d*'/.test("''"));
// → true

// ? - делает часть шаблона необязательной, то есть она может встретиться ноль или один раз.
var neighbor = /neighbou?r/;
console.log(neighbor.test("neighbour"));
// → true
console.log(neighbor.test("neighbor"));
// → true

// {4} - элемент должен встретиться в строке 4 раза
// {2,4} - элемент встретится не менее 2 и не более 4 раз
var dateTime = /\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/;
console.log(dateTime.test("30-1-2003 8:45"));
// → true

// {,5} означает, что шаблон может встретиться от нуля до пяти раз, а {5,} – от пяти и более.

// Чтобы использовать операторы * или + на нескольких элементах сразу, можно использовать круглые скобки.
// Первый и второй плюсы относятся только ко вторым буквам о в словах boo и hoo.
// Третий + относится к целой группе (hoo+)
// Буква i в конце выражения делает регулярку нечувствительной к регистру симолов
var cartoonCrying = /boo+(hoo+)+/i;
console.log(cartoonCrying.test("Boohoooohoohooo"));
// → true


// Итог

// Регулярки – это объекты, представляющие шаблоны поиска в строках.
// Они используют свой синтаксис для выражения этих шаблонов.

// /abc/ Последовательность символов
// /[abc]/ Любой символ из списка
// /[^abc]/ Любой символ, кроме символов из списка
// /[0-9]/ Любой символ из промежутка
// /x+/ Одно или более вхождений шаблона x
// /x+?/ Одно или более вхождений, нежадное
// /x*/ Ноль или более вхождений
// /x?/ Ноль или одно вхождение
// /x{2,4}/ От двух до четырёх вхождений
// /(abc)/ Группа
// /a|b|c/ Любой из нескольких шаблонов
// /\d/ Любая цифра
// /\w/ Любой алфавитно-цифровой символ («буква»)
// /\s/ Любой пробельный символ
// /./ Любой символ, кроме переводов строки
// /\b/ Граница слова
// /^/ Начало строки
// /$/ Конец строки

// У регулярки есть метод test, для проверки того, есть ли шаблон в строке.
// Есть метод exec, возвращающий массив, содержащий все найденные группы. 
// У массива есть свойство index, показывающее, где начался поиск.

// У строк есть метод match для поиска шаблонов, и метод search,
// возвращающий только начальную позицию вхождения.

// Метод replace может заменять вхождения шаблона на другую строку.
// Кроме этого, вы можете передать в replace функцию,
// которая будет строить строчку на замену, основываясь на шаблоне и найденных группах.

// У регулярок есть настройки, которые пишут после закрывающего слеша.
// Опция i делает регулярку регистронезависимой, а опция g делает её глобальной,
// что, кроме прочего, заставляет метод replace заменять все найденные вхождения,
// а не только первое.

// Конструктор RegExp можно использовать для создания регулярок из строк.

// Регулярки – острый инструмент с неудобной ручкой.
// Они сильно упрощают одни задачи, и могут стать неуправляемыми
// при решении других, сложных задач. Часть умения пользоваться
// регулярками состоит в том, чтобы уметь сопротивляться искушению
// запихнуть в них задачу, для которой они не предназначены.